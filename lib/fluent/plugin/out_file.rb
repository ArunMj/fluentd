#
# Fluentd
#
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.
#

require 'fileutils'
require 'zlib'
require 'time'

require 'fluent/plugin/output'
require 'fluent/config/error'
# TODO remove ...
require 'fluent/plugin/file_util'

module Fluent::Plugin
  class FileOutput < Output
    Fluent::Plugin.register_output('file', self)

    helpers :formatter, :inject, :compat_parameters

    SUPPORTED_COMPRESS = [:text, :gz, :gzip]
    SUPPORTED_COMPRESS_MAP = {
      text: nil,
      gz: :gzip,
      gzip: :gzip,
    }

    FILE_PERMISSION = 0644
    DIR_PERMISSION = 0755

    DEFAULT_TIMEKEY = 60 * 60 * 24

    desc "The Path of the file."
    config_param :path, :string

    desc "The flushed chunk is appended to existence file or not."
    config_param :append, :bool, default: false
    desc "Compress flushed file."
    config_param :compress, :enum, list: SUPPORTED_COMPRESS, default: :text
    desc "Execute compression again even when buffer chunk is already compressed."
    config_param :recompress, :bool, default: false
    desc "Create symlink to temporary buffered file when buffer_type is file."
    config_param :symlink_path, :string, default: nil

    config_section :format, init: true do
      config_set_default :@type, 'out_file'
    end

    config_section :buffer do
      config_set_default :@type, 'file'
      config_set_default :chunk_keys, ['time']
      config_set_default :timekey, DEFAULT_TIMEKEY
    end

    module SymlinkBufferMixin
      def symlink_path=(path)
        @_symlink_path = path
      end

      def generate_chunk(metadata)
        chunk = super
        # "symlink" feature is to link from symlink_path to the latest file chunk. Records with latest
        # timekey will be appended into that file chunk. On the other side, resumed file chunks might NOT
        # have timekey, especially in the cases that resumed file chunks are generated by Fluentd v0.12.
        # These chunks will be enqueued immediately, and will be flushed soon.
        latest_chunk = metadata_list.select{|m| m.timekey }.sort_by(&:timekey).last
        if chunk.metadata == latest_chunk
          FileUtils.ln_sf(chunk.path, @_symlink_path)
        end
        chunk
      end
    end

    def configure(conf)
      compat_parameters_convert(conf, :formatter, :buffer, :inject, default_chunk_key: "time")

      # v0.14 file buffer handles path as directory if '*' is missing
      # 'dummy_path' is not to raise configuration error for 'path' in file buffer plugin,
      # but raise it in this plugin.
      if conf.elements(name: 'buffer').empty?
        conf.add_element('buffer', 'time')
      end
      buffer_conf = conf.elements(name: 'buffer').first
      unless buffer_conf.has_key?('path')
        buffer_conf['path'] = conf['path'] || '/tmp/dummy_path'
      end

      super

      @compress_method = SUPPORTED_COMPRESS_MAP[@compress]

      @path_template = generate_path_template(@path, @buffer_config.timekey, @append, @compress_method)
      # TODO: consider placeholders, like ${tag[0]} or ${unknown_field}
      #       add output api to list placeholders in template
      test_metadata = metadata('test.tag', Fluent::Engine.now, {'message' => 'dummy record'})
      test_path = extract_placeholders(@path_template, test_metadata)
      unless ::Fluent::FileUtil.writable_p?(test_path)
        raise Fluent::ConfigError, "out_file: `#{test_path}` is not writable"
      end

      @formatter = formatter_create(conf: conf.elements('format').first)

      if @symlink_path && @buffer.respond_to?(:path)
        @buffer.extend SymlinkBufferMixin
        @buffer.symlink_path = @symlink_path
      end

      @dir_perm = system_config.dir_permission || DIR_PERMISSION
      @file_perm = system_config.file_permission || FILE_PERMISSION
    end

    def format(tag, time, record)
      r = inject_values_to_record(tag, time, record)
      @formatter.format(tag, time, r)
    end

    def write(chunk)
      path = extract_placeholders(@path_template, chunk.metadata)
      FileUtils.mkdir_p File.dirname(path), mode: @dir_perm

      unless @append
        path = find_filepath_available(path)
      end

      case @compress_method
      when nil
        File.open(path, "ab", @file_perm) do |f|
          chunk.write_to(f)
        end
      when :gzip
        if @buffer.compress != :gzip || @recompress
          File.open(path, "ab", @file_perm) do |f|
            gz = Zlib::GzipWriter.new(f)
            chunk.write_to(gz, compressed: :text)
            gz.close
          end
        else
          File.open(path, "ab", @file_perm) do |f|
            chunk.write_to(f, compressed: :gzip)
          end
        end
      else
        raise "BUG: unknown compression method #{@compress_method}"
      end
    end

    def secondary_init(primary)
      # don't warn even if primary.class is not FileOutput
      # TODO: recommend out_secondary_file
    end

    def timekey_to_timeformat(timekey)
      case timekey
      when nil          then ''
      when 0...60       then '%Y%m%d%H%M%S' # 60 exclusive
      when 60...3600    then '%Y%m%d%H%M'
      when 3600...86400 then '%Y%m%d%H'
      else                   '%Y%m%d'
      end
    end

    def compression_suffix(compress)
      case compress
      when :gzip then '.gz'
      when nil then ''
      else
        raise ArgumentError, "unknown compression type #{compress}"
      end
    end

    # /path/to/dir/file.*      -> /path/to/dir/file.%Y%m%d
    # /path/to/dir/file.*.data -> /path/to/dir/file.%Y%m%d.data
    # /path/to/dir/file        -> /path/to/dir/file.%Y%m%d.log
    #   %Y%m%d -> %Y%m%d_** (non append)
    # + .gz (gzipped)
    def generate_path_template(original, timekey, append, compress)
      comp_suffix = compression_suffix(compress)
      if original.index('*')
        if append
          original.gsub('*', timekey_to_timeformat(timekey)) + comp_suffix
        else
          original.gsub('*', timekey_to_timeformat(timekey) + '_**') + comp_suffix
        end
      else
        if timekey
          if append
            "#{original}.#{timekey_to_timeformat(timekey)}.log#{comp_suffix}"
          else
            "#{original}.#{timekey_to_timeformat(timekey)}_**.log#{comp_suffix}"
          end
        else
          if append
            "#{original}.log#{comp_suffix}"
          else
            "#{original}_**.log#{comp_suffix}"
          end
        end
      end
    end

    def find_filepath_available(path_with_placeholder) # for non-append
      raise "BUG: index placeholder not found in path: #{path_with_placeholder}" unless path_with_placeholder.index('_**')
      i = 0
      while path = path_with_placeholder.sub('_**', "_#{i}")
        break unless File.exist?(path)
        i += 1
      end
      path
    end
  end
end
